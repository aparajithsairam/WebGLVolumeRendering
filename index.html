
<html>

<head>
<title>Volumtric Rendering and Slicing</title>
<meta http-equiv="content-type" content="text/html; charset=ISO-8859-1">

<script type="text/javascript" src="glMatrix-0.9.5.min.js"></script>
<script type="text/javascript" src="webgl-utils.js"></script>

<script id="shader-fs" type="x-shader/x-fragment">
    precision mediump float;
	const float SPHERE_CENTER = 0.0;
	const float SPHERE_RADIUS = 40.0;
	const float delt = 1.0;
	const float STEP = 1.5;
	const float PI = 3.1415926;
	const float fovy = (45.0 / 180.0) * PI;
	const vec3 backRGB = vec3(0.27, 0.51, 0.71);
	const vec3 smokeColor = vec3(1.0, 1.0, 1.0);
	const float KAPPA = 1.0;	// Artistic variable
	
	
	uniform sampler2D uSampler;
	uniform vec2 textureSize;
	uniform vec3 eye;
	uniform vec3 up;
	uniform vec3 viewDir;
	uniform vec3 gridOrigin;
	uniform vec3 gridSize;
	uniform vec2 resolution;
	uniform vec3 lightPos[10];
	uniform vec3 lightCol[10];
	uniform int numberOfLights;
	uniform float planeDistance;
	uniform mat4 rotation;
	
    varying vec2 vTextureCoord;

	// Noise Functions
	float snoise(vec2 v);
	float snoise(vec3 v);
	float snoise(vec4 v);
	vec2 cellular(vec2 P);

	
vec4 _mod289(vec4 x)
{
  return x - floor(x * (1.0 / 289.0)) * 289.0;
}

vec3 _mod289(vec3 x)
{
    return x - floor(x * (1.0 / 289.0)) * 289.0;
}

vec2 _mod289(vec2 x) 
{
    return x - floor(x * (1.0 / 289.0)) * 289.0;
}

float _mod289(float x)
{
    return x - floor(x * (1.0 / 289.0)) * 289.0;
}
  
vec4 _permute(vec4 x)
{
    return _mod289(((x*34.0)+1.0)*x);
}

vec3 _permute(vec3 x)
{
    return _mod289(((x*34.0)+1.0)*x);
}

float _permute(float x) 
{
    return _mod289(((x*34.0)+1.0)*x);
}

vec4 _taylorInvSqrt(vec4 r)
{
    return 1.79284291400159 - 0.85373472095314 * r;
}

float _taylorInvSqrt(float r)
{
    return 1.79284291400159 - 0.85373472095314 * r;
}

vec4 _grad4(float j, vec4 ip)
{
    const vec4 ones = vec4(1.0, 1.0, 1.0, -1.0);
    vec4 p,s;

    p.xyz = floor( fract (vec3(j) * ip.xyz) * 7.0) * ip.z - 1.0;
    p.w = 1.5 - dot(abs(p.xyz), ones.xyz);
    s = vec4(lessThan(p, vec4(0.0)));
    p.xyz = p.xyz + (s.xyz*2.0 - 1.0) * s.www; 

    return p;
}
  
/*
 * Implemented by Ian McEwan, Ashima Arts, and distributed under the MIT License.  {@link https://github.com/ashima/webgl-noise}
 */  
float snoise(vec2 v)
{
    const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0
                        0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)
                       -0.577350269189626,  // -1.0 + 2.0 * C.x
                        0.024390243902439); // 1.0 / 41.0
    // First corner
    vec2 i  = floor(v + dot(v, C.yy) );
    vec2 x0 = v -   i + dot(i, C.xx);

    // Other corners
    vec2 i1;
    i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);
    vec4 x12 = x0.xyxy + C.xxzz;
    x12.xy -= i1;

    // Permutations
    i = _mod289(i); // Avoid truncation effects in permutation
    vec3 p = _permute( _permute( i.y + vec3(0.0, i1.y, 1.0 )) + i.x + vec3(0.0, i1.x, 1.0 ));

    vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);
    m = m*m ;
    m = m*m ;

    // Gradients: 41 points uniformly over a line, mapped onto a diamond.
    // The ring size 17*17 = 289 is close to a multiple of 41 (41*7 = 287)
    vec3 x = 2.0 * fract(p * C.www) - 1.0;
    vec3 h = abs(x) - 0.5;
    vec3 ox = floor(x + 0.5);
    vec3 a0 = x - ox;

    // Normalise gradients implicitly by scaling m
    // Approximation of: m *= inversesqrt( a0*a0 + h*h );
    m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );

    // Compute final noise value at P
    vec3 g;
    g.x  = a0.x  * x0.x  + h.x  * x0.y;
    g.yz = a0.yz * x12.xz + h.yz * x12.yw;
    return 130.0 * dot(m, g);
}

float snoise(vec3 v)
{ 
    const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;
    const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);

    // First corner
    vec3 i  = floor(v + dot(v, C.yyy) );
    vec3 x0 =   v - i + dot(i, C.xxx) ;

    // Other corners
    vec3 g = step(x0.yzx, x0.xyz);
    vec3 l = 1.0 - g;
    vec3 i1 = min( g.xyz, l.zxy );
    vec3 i2 = max( g.xyz, l.zxy );

    //   x0 = x0 - 0.0 + 0.0 * C.xxx;
    //   x1 = x0 - i1  + 1.0 * C.xxx;
    //   x2 = x0 - i2  + 2.0 * C.xxx;
    //   x3 = x0 - 1.0 + 3.0 * C.xxx;
    vec3 x1 = x0 - i1 + C.xxx;
    vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y
    vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y

    // Permutations
    i = _mod289(i); 
    vec4 p = _permute( _permute( _permute( 
                i.z + vec4(0.0, i1.z, i2.z, 1.0 ))
              + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) 
              + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));

    // Gradients: 7x7 points over a square, mapped onto an octahedron.
    // The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)
    float n_ = 0.142857142857; // 1.0/7.0
    vec3  ns = n_ * D.wyz - D.xzx;

    vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)

    vec4 x_ = floor(j * ns.z);
    vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)

    vec4 x = x_ *ns.x + ns.yyyy;
    vec4 y = y_ *ns.x + ns.yyyy;
    vec4 h = 1.0 - abs(x) - abs(y);

    vec4 b0 = vec4( x.xy, y.xy );
    vec4 b1 = vec4( x.zw, y.zw );

    //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;
    //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;
    vec4 s0 = floor(b0)*2.0 + 1.0;
    vec4 s1 = floor(b1)*2.0 + 1.0;
    vec4 sh = -step(h, vec4(0.0));

    vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;
    vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;

    vec3 p0 = vec3(a0.xy,h.x);
    vec3 p1 = vec3(a0.zw,h.y);
    vec3 p2 = vec3(a1.xy,h.z);
    vec3 p3 = vec3(a1.zw,h.w);

    //Normalise gradients
    vec4 norm = _taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));
    p0 *= norm.x;
    p1 *= norm.y;
    p2 *= norm.z;
    p3 *= norm.w;

    // Mix final noise value
    vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);
    m = m * m;
    return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), 
                                dot(p2,x2), dot(p3,x3) ) );
}

float snoise(vec4 v)
{
    const vec4  C = vec4( 0.138196601125011,  // (5 - sqrt(5))/20  G4
                          0.276393202250021,  // 2 * G4
                          0.414589803375032,  // 3 * G4
                         -0.447213595499958); // -1 + 4 * G4

    // (sqrt(5) - 1)/4 = F4, used once below
    #define F4 0.309016994374947451

    // First corner
    vec4 i  = floor(v + dot(v, vec4(F4)) );
    vec4 x0 = v -   i + dot(i, C.xxxx);

    // Other corners

    // Rank sorting originally contributed by Bill Licea-Kane, AMD (formerly ATI)
    vec4 i0;
    vec3 isX = step( x0.yzw, x0.xxx );
    vec3 isYZ = step( x0.zww, x0.yyz );
    //  i0.x = dot( isX, vec3( 1.0 ) );
    i0.x = isX.x + isX.y + isX.z;
    i0.yzw = 1.0 - isX;
    //  i0.y += dot( isYZ.xy, vec2( 1.0 ) );
    i0.y += isYZ.x + isYZ.y;
    i0.zw += 1.0 - isYZ.xy;
    i0.z += isYZ.z;
    i0.w += 1.0 - isYZ.z;

    // i0 now contains the unique values 0,1,2,3 in each channel
    vec4 i3 = clamp( i0, 0.0, 1.0 );
    vec4 i2 = clamp( i0-1.0, 0.0, 1.0 );
    vec4 i1 = clamp( i0-2.0, 0.0, 1.0 );

    //  x0 = x0 - 0.0 + 0.0 * C.xxxx
    //  x1 = x0 - i1  + 1.0 * C.xxxx
    //  x2 = x0 - i2  + 2.0 * C.xxxx
    //  x3 = x0 - i3  + 3.0 * C.xxxx
    //  x4 = x0 - 1.0 + 4.0 * C.xxxx
    vec4 x1 = x0 - i1 + C.xxxx;
    vec4 x2 = x0 - i2 + C.yyyy;
    vec4 x3 = x0 - i3 + C.zzzz;
    vec4 x4 = x0 + C.wwww;

    // Permutations
    i = _mod289(i); 
    float j0 = _permute( _permute( _permute( _permute(i.w) + i.z) + i.y) + i.x);
    vec4 j1 = _permute( _permute( _permute( _permute (
               i.w + vec4(i1.w, i2.w, i3.w, 1.0 ))
             + i.z + vec4(i1.z, i2.z, i3.z, 1.0 ))
             + i.y + vec4(i1.y, i2.y, i3.y, 1.0 ))
             + i.x + vec4(i1.x, i2.x, i3.x, 1.0 ));

    // Gradients: 7x7x6 points over a cube, mapped onto a 4-cross polytope
    // 7*7*6 = 294, which is close to the ring size 17*17 = 289.
    vec4 ip = vec4(1.0/294.0, 1.0/49.0, 1.0/7.0, 0.0) ;

    vec4 p0 = _grad4(j0,   ip);
    vec4 p1 = _grad4(j1.x, ip);
    vec4 p2 = _grad4(j1.y, ip);
    vec4 p3 = _grad4(j1.z, ip);
    vec4 p4 = _grad4(j1.w, ip);

    // Normalise gradients
    vec4 norm = _taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));
    p0 *= norm.x;
    p1 *= norm.y;
    p2 *= norm.z;
    p3 *= norm.w;
    p4 *= _taylorInvSqrt(dot(p4,p4));

    // Mix contributions from the five corners
    vec3 m0 = max(0.6 - vec3(dot(x0,x0), dot(x1,x1), dot(x2,x2)), 0.0);
    vec2 m1 = max(0.6 - vec2(dot(x3,x3), dot(x4,x4)            ), 0.0);
    m0 = m0 * m0;
    m1 = m1 * m1;
    return 49.0 * ( dot(m0*m0, vec3( dot( p0, x0 ), dot( p1, x1 ), dot( p2, x2 )))
                  + dot(m1*m1, vec2( dot( p3, x3 ), dot( p4, x4 ) ) ) ) ;
}

///////////////////////////////////////////////////////////////////////////////

/*
 * Cellular noise ("Worley noise") in 2D in GLSL.
 * Copyright (c) Stefan Gustavson 2011-04-19. All rights reserved.
 * This code is released under the conditions of the MIT license.
 * See LICENSE file for details.
 */
 
// Permutation polynomial: (34x^2 + x) mod 289
vec3 _permute289(vec3 x)
{
    return mod((34.0 * x + 1.0) * x, 289.0);
}

/*
 * Implemented by Stefan Gustavson, and distributed under the MIT License.  {@link http://openglinsights.git.sourceforge.net/git/gitweb.cgi?p=openglinsights/openglinsights;a=tree;f=proceduraltextures}
 */  
vec2 cellular(vec2 P)
// Cellular noise, returning F1 and F2 in a vec2.
// Standard 3x3 search window for good F1 and F2 values
{
#define K 0.142857142857 // 1/7
#define Ko 0.428571428571 // 3/7
#define jitter 1.0 // Less gives more regular pattern
    vec2 Pi = mod(floor(P), 289.0);
    vec2 Pf = fract(P);
    vec3 oi = vec3(-1.0, 0.0, 1.0);
    vec3 of = vec3(-0.5, 0.5, 1.5);
    vec3 px = _permute289(Pi.x + oi);
    vec3 p = _permute289(px.x + Pi.y + oi); // p11, p12, p13
    vec3 ox = fract(p*K) - Ko;
    vec3 oy = mod(floor(p*K),7.0)*K - Ko;
    vec3 dx = Pf.x + 0.5 + jitter*ox;
    vec3 dy = Pf.y - of + jitter*oy;
    vec3 d1 = dx * dx + dy * dy; // d11, d12 and d13, squared
    p = _permute289(px.y + Pi.y + oi); // p21, p22, p23
    ox = fract(p*K) - Ko;
    oy = mod(floor(p*K),7.0)*K - Ko;
    dx = Pf.x - 0.5 + jitter*ox;
    dy = Pf.y - of + jitter*oy;
    vec3 d2 = dx * dx + dy * dy; // d21, d22 and d23, squared
    p = _permute289(px.z + Pi.y + oi); // p31, p32, p33
    ox = fract(p*K) - Ko;
    oy = mod(floor(p*K),7.0)*K - Ko;
    dx = Pf.x - 1.5 + jitter*ox;
    dy = Pf.y - of + jitter*oy;
    vec3 d3 = dx * dx + dy * dy; // d31, d32 and d33, squared
    // Sort out the two smallest distances (F1, F2)
    vec3 d1a = min(d1, d2);
    d2 = max(d1, d2); // Swap to keep candidates for F2
    d2 = min(d2, d3); // neither F1 nor F2 are now in d3
    d1 = min(d1a, d2); // F1 is now in d1
    d2 = max(d1a, d2); // Swap to keep candidates for F2
    d1.xy = (d1.x < d1.y) ? d1.xy : d1.yx; // Swap if smaller
    d1.xz = (d1.x < d1.z) ? d1.xz : d1.zx; // F1 is in d1.x
    d1.yz = min(d1.yz, d2.yz); // F2 is now not in d2.yz
    d1.y = min(d1.y, d1.z); // nor in  d1.z
    d1.y = min(d1.y, d2.x); // F2 is in d1.y, we're done.
    return sqrt(d1.xy);
}
	
	
	// My functions from here
	int round(float x)
	{
		if(x > 0.0)
		{
			return int(floor(x + 0.5));
		}
		else
		{
			return int(ceil(x - 0.5));
		}
	}
	
	// To determin if position is in voxels space or not
	bool outOfVoxelSpace(vec3 pos)
	{
		if((pos.x >= gridOrigin.x) && (pos.x < gridOrigin.x + gridSize.x) &&
				(pos.y >= gridOrigin.y) && (pos.y < gridOrigin.y + gridSize.y) &&
				(pos.z >= gridOrigin.z) && (pos.z < gridOrigin.z + gridSize.z))
		{
			return false;
		}
		else
		{
			return true;
		}
	}
	
	//Returns voxel index
	float getVoxelIndex(vec3 worldPos)
	{
		if(outOfVoxelSpace(worldPos))
		{
			return -1.0;
		}
		//worldPos = clamp(worldPos, gridOrigin, gridOrigin + gridSize - vec3(1.0));
		return (worldPos.x - gridOrigin.x + gridSize.x * (worldPos.y - gridOrigin.y) + gridSize.x * gridSize.y * (worldPos.z - gridOrigin.z));
	}
	
	//Returns texture co-ordinate containing density of given voxel
	vec2 getTextureCoords(float voxelIndex)
	{
		vec2 texCoord;
		texCoord.s = mod(voxelIndex, textureSize.x) / (textureSize.x - 1.0);
		texCoord.t = floor(voxelIndex / textureSize.x) / (textureSize.y - 1.0);
		return texCoord;
	}
	
	//Returns density of a point in grid space
	float getDensity(vec3 worldPos)
	{
		float voxelIndex = getVoxelIndex(worldPos);
		if(voxelIndex < 0.0)
			return 0.0;
		vec2 texturePos = getTextureCoords(voxelIndex);
		return ((texture2D(uSampler, texturePos)).r);
	}
	
	//For procedurally determining density of a point in space
	float getSphereDensity(vec3 worldPos, vec3 sphereCenter, float sphereRadius)
	{
		float dist = distance(worldPos, sphereCenter);
		if(dist > sphereRadius)
		{
			return 0.0;
		}
		else
		{
			return (1.0 - dist / sphereRadius);
		}
	}
	
	// Returns -1 or 0, if no intersection, 1 if one intersection, 2 if two intersections
	int boxIntersectionTest(const in vec3 dir, out vec3 intersectionPoint1, out vec3 intersectionPoint2)
	{
		int numberOfIntersections = 0;
		
		vec3 bounds[2];
		bounds[0] = gridOrigin;
		bounds[1] = gridOrigin + gridSize;

		vec3 invDirection = vec3(1.0 / dir.x, 1.0 / dir.y, 1.0 / dir.z);
		int axisMin = 100;	//0 = X, 1 = Y, 2 = Z
		int axisMax = 100;

		float tmin = -10000000.0, tmax = 1000000.0, txmin, txmax, tymin, tymax, tzmin, tzmax;
		if(invDirection.x < 0.0)
		{
			txmin = (bounds[1].x - eye.x) * invDirection.x;
			txmax = (bounds[0].x - eye.x) * invDirection.x;
		}
		else
		{
			txmin = (bounds[0].x - eye.x) * invDirection.x;
			txmax = (bounds[1].x - eye.x) * invDirection.x;
		}

		if(txmin <= 0.0 && txmax <= 0.0)
		{
			return -1;
		}

		if(txmin > tmin && txmin > 0.0)
		{
			tmin = txmin;
			axisMin = 0;
		}

		if(txmax < tmax && txmax > 0.0)
		{
			tmax = txmax;
			axisMax = 0;
		}
		
		if(invDirection.y < 0.0)
		{
			tymin = (bounds[1].y - eye.y) * invDirection.y;
			tymax = (bounds[0].y - eye.y) * invDirection.y;
		}
		else
		{
			tymin = (bounds[0].y - eye.y) * invDirection.y;
			tymax = (bounds[1].y - eye.y) * invDirection.y;
		}

		if(tymin <= 0.0 && tymax <= 0.0)
		{
			return -1;
		}

		if((tmin > tymax) || (tymin > tmax))
		{
			return -1;
		}

		if(tymin > tmin && tymin > 0.0)
		{
			tmin = tymin;
			axisMin = 1;
		}

		if(tymax < tmax && tymax > 0.0)
		{
			tmax = tymax;
			axisMax = 1;
		}
		
		if(invDirection.z < 0.0)
		{
			tzmin = (bounds[1].z - eye.z) * invDirection.z;
			tzmax = (bounds[0].z - eye.z) * invDirection.z;
		}
		else
		{
			tzmin = (bounds[0].z - eye.z) * invDirection.z;
			tzmax = (bounds[1].z - eye.z) * invDirection.z;
		}

		if(tzmin <= 0.0 && tzmax <= 0.0)
		{
			return -1;
		}

		if((tmin > tzmax) || (tzmin > tmax))
			return -1;

		if(tzmin > tmin && tzmin > 0.0)
		{
			tmin = tzmin;
			axisMin = 2;
		}

		if(tzmax < tmax && tzmax > 0.0)
		{
			tmax = tzmax;
			axisMax = 2;
		}

		if(axisMin != 100)
		{
			intersectionPoint1 = eye + tmin * dir;
			++numberOfIntersections;
		}
		if(axisMax != 100)
		{
			intersectionPoint2 = eye + tmax * dir;
			++numberOfIntersections;
		}

		return numberOfIntersections;
	}
	
	//Converts 0-1 to image co-ordinates
	vec2 getImagePixel(vec2 textureCoord)
	{
		return textureCoord * resolution;
	}
	
	//Linear interpolation
	float lerp(float den1, float den2, float t)
	{
		return mix(den1, den2, (den2 - den1) / delt);
	}
	
	// Gives amount of color reaching a voxel
	float findQ(vec3 voxelPos, vec3 lightPosition)	// Gives transmittance of a voxel from  a light
	{
		if(outOfVoxelSpace(voxelPos))
		{
			return 1.0;
		}

		vec3 lightDirection;
		lightDirection = lightPosition - voxelPos;
		float magLightDir = length(lightDirection);
		if(magLightDir > 0.001)
		{
			lightDirection = normalize(lightDirection);
		}
		else
		{
			return 1.0;
		}

		vec3 l = voxelPos;			//instataneous position of light ray
		float Q = 0.0;					// Q value
		float den = 0.0;					//cumulative density

		float f = 0.0;
		for(float f = 0.0; f <= 64.0; f += STEP)
		{
			l += STEP * lightDirection;
			if(outOfVoxelSpace(l))
			{
				break;
			}
			
			//Noise from GLSL----------------------
			/*
			vec2 rg = gl_FragCoord.xy / resolution; // color components between 0.0 and 1.0
			float sairam = snoise((-gridOrigin + l));
			float density = (getSphereDensity(l, vec3(SPHERE_CENTER), SPHERE_RADIUS) / (delt / STEP));
			if(density > 0.0)
			{
				density += sairam;
			}
			den += density;
			//---------------------------
			*/
			
			//Procedural Sphere
			//den += (getSphereDensity(l, vec3(SPHERE_CENTER), SPHERE_RADIUS) / (delt / STEP));
			
			//Density from texture
			den += (getDensity(vec3(floor(l))));
		}
		Q = exp(-1.0 * KAPPA * den);
		return Q;
	}
	
	// For slicing 
	vec3 slice(const vec3 dir)
	{
		vec3 color = vec3(0.0);
		vec3 ray;	// Instantaneous Ray Position
		vec3 intersectionPoint1 = vec3(-1000.0), intersectionPoint2 = vec3(-1000.0);
		int numberOfIntersections = boxIntersectionTest(dir, intersectionPoint1, intersectionPoint2);
		if(numberOfIntersections <= 0)	// Ray did not hit grid
		{
			return backRGB;
		}
		else if(numberOfIntersections == 1)	//Eye is inside the Grid
		{
			ray = eye;
			if((intersectionPoint1.x <= -999.999 && intersectionPoint1.x >= -1000.001)
				&& (intersectionPoint1.y <= -999.999 && intersectionPoint1.y >= -1000.001)
					&& (intersectionPoint1.z <= -999.999 && intersectionPoint1.z >= -1000.001))
			{
				intersectionPoint1 = eye;
			}
			else
			{
				intersectionPoint2 = eye;
			}
		}
		else
		{
			ray = intersectionPoint1;
		}
		float kappaAndStep = -1.0 * KAPPA * STEP;	//For reducing number of multiplications
		float reciKappa = 1.0 / KAPPA;
		float deltaTrans = 0.0;
		float transmittance = 1.0;
		float dist = distance(intersectionPoint1, intersectionPoint2);
		float voxelIndex = getVoxelIndex(intersectionPoint1);
		//For Debugging, please ignore
		//vec2 texturePos = getTextureCoords(voxelIndex);
		//return vec3((texturePos.s - 100.0 / 1023.0) * textureSize.x / 24.0, 0.0, 0.0);
		//return vec3((getVoxelIndex(floor(intersectionPoint1)) - 100.0) / 24.0);
		//return vec3((getVoxelIndex(floor(intersectionPoint1)) - 990000.0) / 9999.0);
		//return vec3(getSphereDensity(vec3(floor(intersectionPoint1) - vec3(0.0, 0.0, planeDistance)), vec3(SPHERE_CENTER), SPHERE_RADIUS));
		
		//Actual code for slicing
		return vec3(getDensity(floor(intersectionPoint1) - vec3(0.0, 0.0, planeDistance)));
	}
	
	//Returns color of a pixel along a ray direction
	vec3 rayCast(const vec3 dir)
	{
		vec3 color = vec3(0.0);
		vec3 ray;	// Instantaneous Ray Position
		vec3 intersectionPoint1 = vec3(-1000.0), intersectionPoint2 = vec3(-1000.0);
		int numberOfIntersections = boxIntersectionTest(dir, intersectionPoint1, intersectionPoint2);
		if(numberOfIntersections <= 0)	// Ray did not hit grid
		{
			return backRGB;
		}
		else if(numberOfIntersections == 1)	//Eye is inside the Grid
		{
			ray = eye;
			if((intersectionPoint1.x <= -999.999 && intersectionPoint1.x >= -1000.001)
				&& (intersectionPoint1.y <= -999.999 && intersectionPoint1.y >= -1000.001)
					&& (intersectionPoint1.z <= -999.999 && intersectionPoint1.z >= -1000.001))
			{
				intersectionPoint1 = eye;
			}
			else
			{
				intersectionPoint2 = eye;
			}
		}
		else
		{
			ray = intersectionPoint1;
		}
		float kappaAndStep = -1.0 * KAPPA * STEP;	//For reducing number of multiplications
		float reciKappa = 1.0 / KAPPA;
		float deltaTrans = 0.0;
		float transmittance = 1.0;
		float dist = distance(intersectionPoint1, intersectionPoint2);
		float voxelIndex = getVoxelIndex(intersectionPoint1);
		
		for(float f = 0.0; f < 64.0; f += STEP)
		{
			ray += STEP * dir;
			if(f > dist || transmittance < 0.01)
			{
				break;
			}
			//Noise from GLSL-------------------------------------------------------------------------------
			/*
			float density = getSphereDensity(ray, vec3(SPHERE_CENTER), SPHERE_RADIUS);
			vec2 rg = gl_FragCoord.xy / resolution; // color components between 0.0 and 1.0
			float sairam = snoise((-gridOrigin + ray));
			if(density > 0.001)
			{
				 density += sairam * 0.10;
			}
			//------------------------------------------------------------------------------------
			*/
			//float density = getSphereDensity(ray, vec3(SPHERE_CENTER), SPHERE_RADIUS);
			float density = getDensity(vec3(floor(ray)));
			deltaTrans = exp(kappaAndStep * density);
			transmittance *= deltaTrans;
			float Q;
			Q = findQ(ray, lightPos[0]);
			color += (reciKappa * (1.0 - deltaTrans) * smokeColor * lightCol[0] * transmittance * Q);
			//Q = findQ(ray, lightPos[1]);
			//color += (reciKappa * (1.0 - deltaTrans) * smokeColor * lightCol[1] * transmittance * Q);
		}
		color += (reciKappa * backRGB * transmittance);
		return color;
	}
	
	//Generates ray
	vec3 volumeRender()
	{
		vec2 pixel = getImagePixel(vTextureCoord);
		float distanceFromCenter = (resolution.y / 2.0) / tan(fovy);
		vec3 c = distanceFromCenter * viewDir;
		vec3 m =  eye + c;
		vec3 a = cross(viewDir, up);
		vec3 b = cross(a, viewDir);
		vec3 h = (resolution.x / 2.0) * normalize(a);
		vec3 v = (distanceFromCenter * tan(fovy)) * normalize(b);
		vec3 p = m + (2.0 * (pixel.x / (resolution.x - 1.0)) - 1.0) * h + (2.0 * (pixel.y / (resolution.y - 1.0)) - 1.0) * v;
		vec3 dir = p - eye;
		dir = normalize(dir);
		return clamp(rayCast(dir), vec3(0.0), vec3(1.0));
	}
	
	//Used for slicing volumetric data along a plane
	//Use 'w' and 's' for moving the plane
	vec3 slicer()
	{
		vec2 pixel = getImagePixel(vTextureCoord);
		float distanceFromCenter = (resolution.y / 2.0) / tan(fovy);
		vec3 c = distanceFromCenter * viewDir;
		vec3 m =  eye + c;
		vec3 a = cross(viewDir, up);
		vec3 b = cross(a, viewDir);
		vec3 h = (resolution.x / 2.0) * normalize(a);
		vec3 v = (distanceFromCenter * tan(fovy)) * normalize(b);
		vec3 p = m + (2.0 * (pixel.x / (resolution.x - 1.0)) - 1.0) * h + (2.0 * (pixel.y / (resolution.y - 1.0)) - 1.0) * v;
		vec3 dir = p - eye;
		dir = normalize(dir);
		return clamp(slice(dir), vec3(0.0), vec3(1.0));
	}

	// Decide here whether you want to do slicing or volumetric rendering
    void main(void) {
	//#define SLICER
	#ifdef SLICER
		gl_FragColor = vec4(slicer(), 1.0);
	#else
		gl_FragColor = vec4(volumeRender(), 1.0);
	#endif
	
	//All debugging below, please ignore
		
		/*
		float ind = getVoxelIndex(vec3(1.0, 1.0, 1.0));
		if(ind <= 515151.001 && ind >= 515150.999)
		{
			gl_FragColor = vec4(0.0, 1.0, 0.0, 1.0);
		}
		else
		{
			gl_FragColor = vec4(0.0, 0.0, 1.0, 1.0);
		}
		*/
		/*
		vec2 textCoordsCalc = getTextureCoords(515151.0);
		if(textCoordsCalc.s <= 0.07715 && textCoordsCalc.s >= 0.07714)
			gl_FragColor = vec4(1.0, 1.0, 0.0, 1.0);
		else
			gl_FragColor = vec4(0.0, 0.0, 1.0, 1.0);
		*/
			
		/*
		vec2 textCoordsCalc = getTextureCoords(505050.0);
		if(textCoordsCalc.t <= 0.48166 && textCoordsCalc.t >= 0.481)
			gl_FragColor = vec4(1.0, 1.0, 0.0, 1.0);
		else
			gl_FragColor = vec4(0.0, 0.0, 1.0, 1.0);
		*/
		
		//gl_FragColor = vec4(vec3(vTextureCoord.s), 1.0);
	
	
		// Testing Texture
		//gl_FragColor = texture2D(uSampler, vTextureCoord);
		
		// Testing sending just RED component, Working
		//gl_FragColor = vec4(0.0, texture2D(uSampler, vec2(vTextureCoord.s, vTextureCoord.t)).r, 0.0, 1.0);
		
		// Testing All Other Stuff
		/*
		if(textureSize.y >= 1023.999 && textureSize.y <= 1024.001)
			gl_FragColor = vec4(0.0, 1.0, 0.0, 1.0);
		else
			gl_FragColor = vec4(0.0, 0.0, 1.0, 1.0);
		*/
    }

</script>

<script id="shader-vs" type="x-shader/x-vertex">
//Nothing Special Here
    attribute vec3 aVertexPosition;
    attribute vec2 aTextureCoord;

    uniform mat4 uMVMatrix;
    uniform mat4 uPMatrix;

    varying vec2 vTextureCoord;


    void main(void) {
        gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);
        vTextureCoord = aTextureCoord;
    }
</script>


<script type="text/javascript">
	//Variables to tweak image
    var gl;
	var eye = [];
	var gridOrigin = [];
	var gridSize = [];
	var resolution = [];
	var up = [];
	var viewDir = [];
	var lightPos = [];
	var lightCol = [];
	var numberOfLights;
	var planeDistance = 30.0;
	
	
	//Some Functions that I wrote for my convenience
	function crossProduct(a, b)
	{
		var result = new Array(3);
		result[0] = a[1] * b[2] - a[2] * b[1];
		result[1] = a[2] * b[0] - a[0] * b[2];
		result[2] = a[0] * b[1] - a[1] * b[0];
		return result;
	}

	function dotProduct(a, b)
	{
		return (a[0] * b[0] + a[1] * b[1] + a[2] * b[2]);
	}

	function distance(a, b)
	{
		return Math.sqrt((a[0] - b[0]) * (a[0] - b[0]) + (a[1] - b[1]) * (a[1] - b[1]) + (a[2] - b[2]) * (a[2] - b[2])); 
	}

	function magnitude(a)
	{	
		return Math.sqrt(a[0] * a[0] + a[1] * a[1] + a[2] * a[2]);
	}
	
	
	// Initializes WebGL
    function initGL(canvas) {
        try {
            gl = canvas.getContext("experimental-webgl");
            gl.viewportWidth = canvas.width;
            gl.viewportHeight = canvas.height;
			var float_texture_ext = gl.getExtension('OES_texture_float');
			if(float_texture_ext == NULL)
			{
				alert("Float Texturing Not Supported!");
			}
        } catch (e) {
        }
        if (!gl) {
            alert("Could not initialise WebGL, sorry :-(");
        }
    }

	// Shader
    function getShader(gl, id) {
        var shaderScript = document.getElementById(id);
        if (!shaderScript) {
            return null;
        }

        var str = "";
        var k = shaderScript.firstChild;
        while (k) {
            if (k.nodeType == 3) {
                str += k.textContent;
            }
            k = k.nextSibling;
        }

        var shader;
        if (shaderScript.type == "x-shader/x-fragment") {
            shader = gl.createShader(gl.FRAGMENT_SHADER);
        } else if (shaderScript.type == "x-shader/x-vertex") {
            shader = gl.createShader(gl.VERTEX_SHADER);
        } else {
            return null;
        }

        gl.shaderSource(shader, str);
        gl.compileShader(shader);

        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
            alert(gl.getShaderInfoLog(shader));
            return null;
        }

        return shader;
    }

	//Initialize Shader
    var shaderProgram;
	
    function initShaders() {
        var fragmentShader = getShader(gl, "shader-fs");
        var vertexShader = getShader(gl, "shader-vs");

        shaderProgram = gl.createProgram();
        gl.attachShader(shaderProgram, vertexShader);
        gl.attachShader(shaderProgram, fragmentShader);
        gl.linkProgram(shaderProgram);

        if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
            alert("Could not initialise shaders");
        }

        gl.useProgram(shaderProgram);

        shaderProgram.vertexPositionAttribute = gl.getAttribLocation(shaderProgram, "aVertexPosition");
        gl.enableVertexAttribArray(shaderProgram.vertexPositionAttribute);

        shaderProgram.textureCoordAttribute = gl.getAttribLocation(shaderProgram, "aTextureCoord");
        gl.enableVertexAttribArray(shaderProgram.textureCoordAttribute);

        shaderProgram.pMatrixUniform = gl.getUniformLocation(shaderProgram, "uPMatrix");
        shaderProgram.mvMatrixUniform = gl.getUniformLocation(shaderProgram, "uMVMatrix");
		shaderProgram.rotation = gl.getUniformLocation(shaderProgram, "rotation");
        shaderProgram.samplerUniform = gl.getUniformLocation(shaderProgram, "uSampler");
		shaderProgram.eye = gl.getUniformLocation(shaderProgram, "eye");
		shaderProgram.gridOrigin = gl.getUniformLocation(shaderProgram, "gridOrigin");
		shaderProgram.gridSize = gl.getUniformLocation(shaderProgram, "gridSize");
		shaderProgram.resolution = gl.getUniformLocation(shaderProgram, "resolution");
		shaderProgram.up = gl.getUniformLocation(shaderProgram, "up");
		shaderProgram.viewDir = gl.getUniformLocation(shaderProgram, "viewDir");
		shaderProgram.lightPos = gl.getUniformLocation(shaderProgram, "lightPos");
		shaderProgram.lightCol = gl.getUniformLocation(shaderProgram, "lightCol");
		shaderProgram.numberOfLights = gl.getUniformLocation(shaderProgram, "numberOfLights");
		shaderProgram.textureSize = gl.getUniformLocation(shaderProgram, "textureSize");
		shaderProgram.planeDistance = gl.getUniformLocation(shaderProgram, "planeDistance");
    }

	// Supporter functions for initializing texture
    function handleLoadedTexture(texture) {
		//Passing Array as Texture
		/*
        gl.bindTexture(gl.TEXTURE_2D, texture);
		gl.pixelStorei(gl.UNPACK_ALIGNMENT, 1);
		//gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGB, 32, 32, 0, gl.RGB, gl.UNSIGNED_BYTE, new Uint8Array(texture.image));
		//gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, parseInt(textureWidth), parseInt(textureHeight), 0, gl.RGBA, gl.FLOAT, new Float32Array(texture.image));
		//Tests for just putting RED component to GPU, Working
		gl.texImage2D(gl.TEXTURE_2D, 0, gl.LUMINANCE, parseInt(textureWidth), parseInt(textureHeight), 0, gl.LUMINANCE, gl.FLOAT, new Float32Array(texture.image));
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
        gl.bindTexture(gl.TEXTURE_2D, null);
		*/
		gl.bindTexture(gl.TEXTURE_2D, texture);
        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, texture.image);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
        gl.bindTexture(gl.TEXTURE_2D, null);
    }

    // Functions for initializing texture
	var volumeTexture;
	var textureWidth = 1024, textureHeight = 1024;
	
	function voxelIndex(a, b, c) {
		return (a - gridOrigin[0] + gridSize[0] * (b - gridOrigin[1]) + gridSize[0] * gridSize[1] * (c - gridOrigin[2]));
	}
	
    function initTexture() {
		var totalTextureSize = textureWidth * textureHeight;
        volumeTexture = gl.createTexture();
		
        // For a normal image
		volumeTexture.image = new Image();
		volumeTexture.image.onload = function () {
            handleLoadedTexture(volumeTexture)
        }
        
		//This is the image which decides densities
		volumeTexture.image.src = "Cloud.bmp";
		
		
		// Testing Texture
		/* Passing alternating colors
		var k = 1;
		var colo = 0;
		for(var i = 0; i < totalTextureSize; ++i, ++k)
		{
			if(colo == 0)
				volumeTexture.image.push(0.0, 0.0, 1.0, 1.0);
			else if(colo == 1)
				volumeTexture.image.push(0.0, 1.0, 0.0, 1.0);
			else
				volumeTexture.image.push(1.0, 0.0, 0.0, 1.0);
			if(k % 33 == 0)
			{
				colo = (colo + 1) % 3;
			}
		}
		*/
		// Serious Experiment to determine how Texturing works
		/*
		volumeTexture.image = new Array(totalTextureSize * 4);
		for(var i = 0; i < totalTextureSize * 4; i += 4)
		{
			if(i < totalTextureSize)
			{
				volumeTexture.image[i] = 0.0;
				volumeTexture.image[i + 1] = 1.0;
				volumeTexture.image[i + 2] = 0.0;
				volumeTexture.image[i + 3] = 1.0;
			}
			else if(i < 2.0 * totalTextureSize)
			{
				volumeTexture.image[i] = 1.0;
				volumeTexture.image[i + 1] = 0.0;
				volumeTexture.image[i + 2] = 0.0;
				volumeTexture.image[i + 3] = 1.0;
			}
			else if(i < 3.0 * totalTextureSize)
			{
				volumeTexture.image[i] = 0.0;
				volumeTexture.image[i + 1] = 0.0;
				volumeTexture.image[i + 2] = 1.0;
				volumeTexture.image[i + 3] = 1.0;
			}
			else
			{
				volumeTexture.image[i] = 1.0;
				volumeTexture.image[i + 1] = 1.0;
				volumeTexture.image[i + 2] = 0.0;
				volumeTexture.image[i + 3] = 1.0;
			}
		}
		*/
		
		//Tests for just putting RED component to GPU, Working Now
		/*
		volumeTexture.image = new Array(totalTextureSize);
		for(var i = 0; i < totalTextureSize; i += 4)
		{
			volumeTexture.image[i] = 0.0;
			volumeTexture.image[i + 1] = 0.0;
			volumeTexture.image[i + 2] = 0.0;
			volumeTexture.image[i + 3] = 0.0;
		}
		*/
		// Actual
		/*
		volumeTexture.image = new Array(totalTextureSize);
		var sphereCenter = [0.0, 0.0, 0.0];
		var sphereRadius = 40.0;
		for(var x = gridOrigin[0]; x < gridOrigin[0] + gridSize[0]; ++x)
		{
			for(var y = gridOrigin[1]; y < gridOrigin[1] + gridSize[1]; ++y)
			{
				for(var z = gridOrigin[2]; z < gridOrigin[2] + gridSize[2]; ++z)
				{
					var tempor = voxelIndex(x, y, z);
					var arr = [x, y, z];
					var dist = distance(sphereCenter, arr);
					if(dist < sphereRadius)
					{
						volumeTexture.image[tempor] = 1.0 - dist / sphereRadius;
					}
					else
					{
						volumeTexture.image[tempor] = 0.0;
					}
				}
			}
		}
		handleLoadedTexture(volumeTexture);
		*/
    }


    var mvMatrix = mat4.create();
    var mvMatrixStack = [];
    var pMatrix = mat4.create();
	var mouseRotation = mat4.create();
	mat4.identity(mouseRotation);

    function mvPushMatrix() {
        var copy = mat4.create();
        mat4.set(mvMatrix, copy);
        mvMatrixStack.push(copy);
    }

    function mvPopMatrix() {
        if (mvMatrixStack.length == 0) {
            throw "Invalid popMatrix!";
        }
        mvMatrix = mvMatrixStack.pop();
    }


    function setUniforms() {
        gl.uniformMatrix4fv(shaderProgram.pMatrixUniform, false, pMatrix);
        gl.uniformMatrix4fv(shaderProgram.mvMatrixUniform, false, mvMatrix);
		gl.uniformMatrix4fv(shaderProgram.rotation, false, mouseRotation);
		gl.uniform3f(shaderProgram.eye, parseFloat(eye[0]), parseFloat(eye[1]), parseFloat(eye[2]));
		gl.uniform3f(shaderProgram.gridOrigin, parseFloat(gridOrigin[0]), parseFloat(gridOrigin[1]), parseFloat(gridOrigin[2]));
		gl.uniform3f(shaderProgram.gridSize, parseFloat(gridSize[0]), parseFloat(gridSize[1]), parseFloat(gridSize[2]));
		gl.uniform2f(shaderProgram.resolution, parseFloat(resolution[0]), parseFloat(resolution[1]));
		gl.uniform3f(shaderProgram.up, parseFloat(up[0]), parseFloat(up[1]), parseFloat(up[2]));
		gl.uniform3f(shaderProgram.viewDir, parseFloat(viewDir[0]), parseFloat(viewDir[1]), parseFloat(viewDir[2]));
		gl.uniform1i(shaderProgram.numberOfLights, parseInt(numberOfLights));
		gl.uniform3fv(shaderProgram.lightPos, lightPos);
		gl.uniform3fv(shaderProgram.lightCol, lightCol);
		gl.uniform2f(shaderProgram.textureSize, parseFloat(textureWidth), parseFloat(textureHeight));
		gl.uniform1f(shaderProgram.planeDistance, parseFloat(planeDistance));
    }


    function degToRad(degrees) {
        return degrees * Math.PI / 180;
    }

	//Functions for giving keyboard interaction
    var currentlyPressedKeys = {};
	
    function handleKeyDown(event) {
        currentlyPressedKeys[event.keyCode] = true;
    }


    function handleKeyUp(event) {
        currentlyPressedKeys[event.keyCode] = false;
    }


    function handleKeys() {
        if (currentlyPressedKeys[33]) {
            // Page Up
            lightPos[2] -= 5;
        }
        if (currentlyPressedKeys[34]) {
            // Page Down
            lightPos[2] += 5;
        }
        if (currentlyPressedKeys[37]) {
            // Left cursor key
            lightPos[0] -= 5;
        }
        if (currentlyPressedKeys[39]) {
            // Right cursor key
            lightPos[0] += 5;
        }
        if (currentlyPressedKeys[38]) {
            // Up cursor key
            lightPos[1] += 5;
        }
        if (currentlyPressedKeys[40]) {
            // Down cursor key
            lightPos[1] -= 5;
        }
		if(currentlyPressedKeys[87]){
			// 'w'
			planeDistance -= 1;
		}
		if(currentlyPressedKeys[83]){
			// 's'
			planeDistance += 1;
		}
		if(currentlyPressedKeys[65]){
			// 'a'
			planeDistance -= 0.05;
		}
		if(currentlyPressedKeys[68]){
			// 'd'
			planeDistance += 0.05;
		}
    }
	
	// Functions for mouse interaction
	var mouseDown = false;
    var lastMouseX = null;
    var lastMouseY = null;

    function handleMouseDown(event) {
        mouseDown = true;
        lastMouseX = event.clientX;
        lastMouseY = event.clientY;
    }


    function handleMouseUp(event) {
        mouseDown = false;
    }

    function handleMouseMove(event) {
        if (!mouseDown) {
            return;
        }
        var newX = event.clientX;
        var newY = event.clientY;

        var deltaX = newX - lastMouseX;
        var newRotationMatrix = mat4.create();
        mat4.identity(newRotationMatrix);
        mat4.rotate(newRotationMatrix, degToRad(deltaX / 10), [0, 1, 0]);
		
        //var deltaY = newY - lastMouseY;
        //mat4.rotate(newRotationMatrix, degToRad(deltaY / 10), [1, 0, 0]);
		
		mat4.multiply(mouseRotation, newRotationMatrix, mouseRotation);
		var centerOfRotation = [(gridOrigin[0] + gridSize[0] / 2.0), (gridOrigin[1] + gridSize[1] / 2.0), (gridOrigin[2] + gridSize[2] / 2.0)];
		viewDir[0] = 0.0;
		viewDir[1] = 0.0;
		viewDir[2] = -1.0;
		mat4.multiplyVec3(mouseRotation, viewDir);
		var distanceOfEyeFromGrid = 135.0;
		eye[0] = centerOfRotation[0] - viewDir[0] * distanceOfEyeFromGrid;
		eye[2] = centerOfRotation[2] - viewDir[2] * distanceOfEyeFromGrid;

        lastMouseX = newX;
        lastMouseY = newY;
    }
	
	var cubeVertexPositionBuffer;
    var cubeVertexTextureCoordBuffer;
    var cubeVertexIndexBuffer;

    function initBuffers() {
        cubeVertexPositionBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexPositionBuffer);
        vertices = [
            -1.0, -1.0,  1.0,
             1.0, -1.0,  1.0,
             1.0,  1.0,  1.0,
            -1.0,  1.0,  1.0
        ];
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
        cubeVertexPositionBuffer.itemSize = 3;
        cubeVertexPositionBuffer.numItems = 4;

        cubeVertexTextureCoordBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexTextureCoordBuffer);
		var textureCoords = [
          0.0, 0.0,
          1.0, 0.0,
          1.0, 1.0,
          0.0, 1.0
        ];
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(textureCoords), gl.STATIC_DRAW);
        cubeVertexTextureCoordBuffer.itemSize = 2;
        cubeVertexTextureCoordBuffer.numItems = 4;

        cubeVertexIndexBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, cubeVertexIndexBuffer);
        var cubeVertexIndices = [
            0, 1, 2, 0, 2, 3
        ];
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(cubeVertexIndices), gl.STATIC_DRAW);
        cubeVertexIndexBuffer.itemSize = 1;
        cubeVertexIndexBuffer.numItems = 6;
    }

	var rota = 0.0;
	var textureCounter = 0;
    function drawScene() {
        gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

        mat4.perspective(45, gl.viewportWidth / gl.viewportHeight, 0.1, 100.0, pMatrix);

        mat4.identity(mvMatrix);

		if(gl.viewportWidth == 512)
			mat4.translate(mvMatrix, [0.0, 0.0, -3.4155]);
		else
			mat4.translate(mvMatrix, [0.0, 0.0, -3.4175]);
		
		//mat4.rotate(mvMatrix, degToRad(rota), [0, 0, 1]);

        gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexPositionBuffer);
        gl.vertexAttribPointer(shaderProgram.vertexPositionAttribute, cubeVertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);

        gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexTextureCoordBuffer);
        gl.vertexAttribPointer(shaderProgram.textureCoordAttribute, cubeVertexTextureCoordBuffer.itemSize, gl.FLOAT, false, 0, 0);
		
        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_2D, volumeTexture);
        gl.uniform1i(shaderProgram.samplerUniform, 0);

        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, cubeVertexIndexBuffer);
        setUniforms(gl.viewportWidth, gl.viewportHeight);
        gl.drawElements(gl.TRIANGLES, cubeVertexIndexBuffer.numItems, gl.UNSIGNED_SHORT, 0);
    }


	// Animate
    var lastTime = 0;
	var frameRate = 0.0;
	
    function animate() {
        var timeNow = new Date().getTime();
        if (lastTime != 0) {
            var elapsed = timeNow - lastTime;
			rota += 2;
			// For displaying Frame Rate
			if(rota % 10 == 0)
			{
				frameRate = 1000.0 / elapsed;
				frameRate *= 100.0;
				frameRate = Math.floor(frameRate) / 100.0;
				document.getElementById('frameRateStuff').innerHTML = frameRate;
			}
			
			// For investigating textures
			/*
			for(var i = 0; i < volumeTexture.image.length && i < rota; ++i)
			{
				volumeTexture.image[i] = 1.0;
				//if(rota % 1024 == 0)
				//{
				//	rota += 1024;
				//	break;
				//}
				
			}
			handleLoadedTexture(volumeTexture);
			*/
			
			// For Moving eye around the scene
			/*
			var centerOfRotation = [(gridOrigin[0] + gridSize[0] / 2.0), (gridOrigin[1] + gridSize[1] / 2.0), (gridOrigin[2] + gridSize[2] / 2.0)];
			eye[0] = 135.0 * Math.cos(rota / 30.0) + centerOfRotation[0];
			eye[1] = 0.0;
			eye[2] = 135.0 * Math.sin(rota / 30.0) + centerOfRotation[2];
			var magEyeToCenter = distance(centerOfRotation, eye);
			viewDir[0] = (centerOfRotation[0] - eye[0]) / magEyeToCenter;
			viewDir[1] = (centerOfRotation[1] - eye[1]) / magEyeToCenter;
			viewDir[2] = (centerOfRotation[2] - eye[2]) / magEyeToCenter;
			*/
        }
        lastTime = timeNow;
    }

	// Clock
    function tick() {
        requestAnimFrame(tick);
		handleKeys();
        drawScene();
        animate();
    }

	function setSceneProperties() {
		eye.push(0.0, 0.0, 135.0);
		gridOrigin.push(-50.0, -50.0, -50.0);
		gridSize.push(100.0, 100.0, 100.0);
		resolution.push(gl.viewportWidth, gl.viewportHeight);
		up.push(0.0, 1.0, 0.0);
		viewDir.push(0.0, 0.0, -1.0);
		numberOfLights = 2;
		lightPos.push(50.0, 50.0, 100.0);
		lightCol.push(1.0, 0.0, 0.0);
		lightPos.push(-50.0, 50.0, 100.0);
		lightCol.push(0.0, 0.0, 1.0);
	}

    function webGLStart() {
        var canvas = document.getElementById("Volume-Renderer");
        initGL(canvas);
		setSceneProperties();
        initShaders();
        initBuffers();
        initTexture();

        gl.clearColor(1.0, 0.0, 0.0, 1.0);
        gl.enable(gl.DEPTH_TEST);
		
		//Keyboard Interaction
		document.onkeydown = handleKeyDown;
        document.onkeyup = handleKeyUp;
		
		//Mouse Interaction
		canvas.onmousedown = handleMouseDown;
		document.onmouseup = handleMouseUp;
		document.onmousemove = handleMouseMove;

        tick();
    }


</script>


</head>


<body onload="webGLStart();">

    <center><canvas id="Volume-Renderer" style="border: none;" width="512" height="512"></canvas></center>
	<center><p>Frame Rate = <b id='frameRateStuff'> 0.0 </b> </p></center>

</body>

</html>
